const fs = require('fs');
const path = require('path');
const TelegramBot = require('node-telegram-bot-api');
const schedule = require('node-schedule');
const moment = require('moment-timezone');
const tzlookup = require('tz-lookup');
const fetch = (...args) => import('node-fetch').then(({ default: fetch }) => fetch(...args));

const token = '7928119970:AAGSbPpGimw1z6cp1oinnTL7S0Izhyi87Sg';
const bot = new TelegramBot(token, { polling: true });

let userSchedules = {};
let userSettings = {};
let scheduledJobs = {};

const dataFilePath = path.join(__dirname, 'schedule.json');

if (fs.existsSync(dataFilePath)) {
    try {
        const data = JSON.parse(fs.readFileSync(dataFilePath, 'utf8'));
        userSchedules = data.schedules || {};
        userSettings = data.settings || {};
    } catch (err) {
        console.error("Ошибка при чтении файла данных:", err);
        userSchedules = {};
        userSettings = {};
    }
} else {
    saveData();
}

function saveData() {
    const data = { schedules: userSchedules, settings: userSettings };
    fs.writeFileSync(dataFilePath, JSON.stringify(data, null, 2));
}

async function getAddressFromCoordinates(latitude, longitude) {
    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`;
        const response = await fetch(url, {
            headers: {
                'User-Agent': 'Your-App-Name (contact@email.com)'
            }
        });

        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const data = await response.json();
        return data.display_name || 'Адрес не найден';
    } catch (err) {
        console.error('Geocoding error:', err);
        return 'Не удалось определить адрес';
    }
}

function cleanupOldEvents(chatId) {
    const now = new Date();
    const tz = (userSettings[chatId] && userSettings[chatId].timezone) || moment.tz.guess();
    let scheduleArr = userSchedules[chatId] || [];
    const newScheduleArr = scheduleArr.filter(pair => {
        const eventDateTime = moment.tz(`${pair.date} ${pair.time}`, 'YYYY-MM-DD HH:mm', tz).toDate();
        return eventDateTime > now;
    });
    if (newScheduleArr.length !== scheduleArr.length) {
        userSchedules[chatId] = newScheduleArr;
        saveData();
        scheduleAllNotificationsForUser(chatId);
    }
}

function scheduleNotificationForUser(chatId, pair, index) {
    let notifyBefore = 10;
    if (userSettings[chatId] && typeof userSettings[chatId].notifyBefore === 'number') {
        notifyBefore = userSettings[chatId].notifyBefore;
    }
    const tz = (userSettings[chatId] && userSettings[chatId].timezone) || moment.tz.guess();
    const eventDateTime = moment.tz(`${pair.date} ${pair.time}`, 'YYYY-MM-DD HH:mm', tz).toDate();
    const notifyTime = new Date(eventDateTime.getTime() - notifyBefore * 60000);

    console.log(`Пользователь ${chatId}: событие "${pair.subject}" в ${eventDateTime} (часовой пояс: ${tz}). Уведомление планируется на ${notifyTime}.`);

    const job = schedule.scheduleJob(notifyTime, () => {
        const message = `⏰ Напоминание!
Пара: ${pair.subject}
Преподаватель: ${pair.teacher}
Место: ${pair.place}
Начало в: ${pair.time} (через ${notifyBefore} минут)`;
        bot.sendMessage(chatId, message);
        console.log(`Уведомление отправлено пользователю ${chatId} для пары "${pair.subject}".`);
    });
    if (!scheduledJobs[chatId]) scheduledJobs[chatId] = {};
    scheduledJobs[chatId][index] = job;
}

function scheduleAllNotificationsForUser(chatId) {
    cleanupOldEvents(chatId);
    if (scheduledJobs[chatId]) {
        for (let key in scheduledJobs[chatId]) {
            if (scheduledJobs[chatId].hasOwnProperty(key)) {
                scheduledJobs[chatId][key].cancel();
            }
        }
        scheduledJobs[chatId] = {};
    }
    const scheduleArr = userSchedules[chatId] || [];
    scheduleArr.forEach((pair, index) => {
        scheduleNotificationForUser(chatId, pair, index);
    });
}

function isValidDate(dateStr) {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return false;
    const dateObj = new Date(dateStr);
    if (isNaN(dateObj.getTime())) return false;
    const parts = dateStr.split('-');
    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10);
    const day = parseInt(parts[2], 10);
    return dateObj.getFullYear() === year &&
        (dateObj.getMonth() + 1) === month &&
        dateObj.getDate() === day;
}

function isValidTime(timeStr) {
    const match = timeStr.match(/^(\d{2}):(\d{2})$/);
    if (!match) return false;
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    if (hours < 0 || hours > 23) return false;
    if (minutes < 0 || minutes > 59) return false;
    return true;
}

const userStates = {};

function sendMainMenu(chatId) {
    const keyboard = {
        reply_markup: {
            inline_keyboard: [
                [{ text: 'Добавить пару', callback_data: 'menu_addpair' }],
                [{ text: 'Просмотреть расписание', callback_data: 'menu_listschedule' }],
                [{ text: 'Настройки', callback_data: 'menu_settings' }],
            ]
        }
    };
    bot.sendMessage(chatId, 'Главное меню:', keyboard);
}

function requestLocation(chatId) {
    const keyboard = {
        reply_markup: {
            keyboard: [
                [{ text: 'Поделиться местоположением', request_location: true }]
            ],
            resize_keyboard: true,
            one_time_keyboard: true
        }
    };
    bot.sendMessage(chatId, 'Для определения вашего часового пояса, пожалуйста, поделитесь своим местоположением:', keyboard);
}

function listSchedule(chatId) {
    cleanupOldEvents(chatId);
    const scheduleArr = userSchedules[chatId] || [];
    if (scheduleArr.length === 0) {
        return bot.sendMessage(chatId, 'Расписание пусто.');
    }
    let message = '*Ваше расписание:*\n';
    const inlineButtons = [];
    scheduleArr.forEach((pair, index) => {
        message += `*${index}.* ${pair.date} ${pair.time} – ${pair.subject} (${pair.place}), преподаватель: ${pair.teacher}\n`;
        inlineButtons.push([{ text: `Удалить ${index}`, callback_data: `delpair|${index}` }]);
    });
    inlineButtons.push([{ text: 'Назад в меню', callback_data: 'menu_back' }]);
    bot.sendMessage(chatId, message, { parse_mode: 'Markdown', reply_markup: { inline_keyboard: inlineButtons } });
}

bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    console.log(`Пользователь подключился: ${chatId}`);

    if (!userSettings[chatId]) {
        userSettings[chatId] = { notifyBefore: 10 };
    }

    if (!userSettings[chatId].timezone) {
        requestLocation(chatId);
    } else {
        const welcomeMsg = `Привет! Я бот-расписание.
Ваш часовой пояс: ${userSettings[chatId].timezone}.
Ваш адрес: ${userSettings[chatId].address || 'не определён'}.
Выберите действие из меню ниже.`;
        bot.sendMessage(chatId, welcomeMsg).then(() => sendMainMenu(chatId));
    }
});

bot.on('message', (msg) => {
    const chatId = msg.chat.id;
    console.log(`Поступило сообщение от пользователя: ${chatId}`);

    if (msg.location) {
        const { latitude, longitude } = msg.location;
        try {
            const timezone = tzlookup(latitude, longitude);
            console.log(`Пользователь ${chatId} поделился местоположением: lat=${latitude}, lon=${longitude}. Определённый часовой пояс: ${timezone}`);
            getAddressFromCoordinates(latitude, longitude)
                .then(address => {
                    console.log(`Адрес пользователя ${chatId}: ${address}`);
                    userSettings[chatId] = userSettings[chatId] || { notifyBefore: 10 };
                    userSettings[chatId].timezone = timezone;
                    userSettings[chatId].address = address;
                    saveData();
                    bot.sendMessage(chatId, `Ваш часовой пояс определён как ${timezone}.\nВаш адрес: ${address}`)
                        .then(() => sendMainMenu(chatId));
                })
                .catch(err => {
                    console.error('Ошибка получения адреса:', err);
                    bot.sendMessage(chatId, 'Не удалось определить ваш адрес. Попробуйте ещё раз.');
                });
            return;
        } catch (err) {
            console.error('Ошибка определения часового пояса:', err);
            bot.sendMessage(chatId, 'Не удалось определить ваш часовой пояс. Попробуйте ещё раз.');
            return;
        }
    }

    if (msg.text && msg.text.startsWith('/')) return;

    if (userStates[chatId]) {
        let state = userStates[chatId];
        const input = msg.text.trim();
        switch (state.step) {
            case 'date':
                if (!isValidDate(input)) {
                    bot.sendMessage(chatId, "Неверный формат или некорректная дата. Введите дату в формате YYYY-MM-DD:");
                    return;
                }
                state.pair.date = input;
                state.step = 'time';
                bot.sendMessage(chatId, "Введите время пары (формат HH:mm):");
                break;
            case 'time':
                if (!isValidTime(input)) {
                    bot.sendMessage(chatId, "Неверный формат или некорректное время. Введите время в формате HH:mm:");
                    return;
                }
                state.pair.time = input;
                state.step = 'place';
                bot.sendMessage(chatId, "Введите место пары:");
                break;
            case 'place':
                state.pair.place = input;
                state.step = 'subject';
                bot.sendMessage(chatId, "Введите предмет пары:");
                break;
            case 'subject':
                state.pair.subject = input;
                state.step = 'teacher';
                bot.sendMessage(chatId, "Введите ФИО преподавателя:");
                break;
            case 'teacher':
                state.pair.teacher = input;
                userSchedules[chatId] = userSchedules[chatId] || [];
                userSchedules[chatId].push(state.pair);
                saveData();
                scheduleNotificationForUser(chatId, state.pair, userSchedules[chatId].length - 1);
                bot.sendMessage(chatId, "Пара успешно добавлена!");
                delete userStates[chatId];
                sendMainMenu(chatId);
                break;
            default:
                delete userStates[chatId];
                bot.sendMessage(chatId, "Ошибка ввода. Пожалуйста, начните заново с команды /start.");
                break;
        }
    }
});

bot.onText(/\/listschedule/, (msg) => {
    const chatId = msg.chat.id;
    console.log(`Пользователь (listschedule): ${chatId}`);
    listSchedule(chatId);
});

bot.onText(/\/settings (\d+)/, (msg, match) => {
    const chatId = msg.chat.id;
    console.log(`Пользователь (settings): ${chatId}`);
    const minutes = parseInt(match[1], 10);
    if (isNaN(minutes) || minutes < 0) {
        return bot.sendMessage(chatId, 'Укажите корректное число минут.');
    }
    userSettings[chatId] = userSettings[chatId] || { notifyBefore: 10 };
    userSettings[chatId].notifyBefore = minutes;
    saveData();
    scheduleAllNotificationsForUser(chatId);
    bot.sendMessage(chatId, `Время уведомления установлено: ${minutes} минут(ы) до начала пары.`)
        .then(() => sendMainMenu(chatId));
});

bot.on('callback_query', async (callbackQuery) => {
    const data = callbackQuery.data;
    const msg = callbackQuery.message;
    const chatId = msg.chat.id;
    console.log(`Пользователь (callback): ${chatId}`);

    if (data === 'menu_addpair') {
        await bot.answerCallbackQuery(callbackQuery.id);
        userStates[chatId] = { step: 'date', pair: {} };
        bot.sendMessage(chatId, "Введите дату пары (формат YYYY-MM-DD):");
    } else if (data === 'menu_listschedule') {
        await bot.answerCallbackQuery(callbackQuery.id);
        listSchedule(chatId);
    } else if (data === 'menu_settings') {
        await bot.answerCallbackQuery(callbackQuery.id);
        bot.sendMessage(chatId,
            'Введите новое время уведомления, используя команду:\n\n`/settings <минут>`\n\nНапример:\n`/settings 15`',
            { parse_mode: 'Markdown' }
        );
    } else if (data === 'menu_back') {
        await bot.answerCallbackQuery(callbackQuery.id);
        sendMainMenu(chatId);
    } else if (data.startsWith('delpair|')) {
        await bot.answerCallbackQuery(callbackQuery.id);
        const index = parseInt(data.split('|')[1], 10);
        const scheduleArr = userSchedules[chatId] || [];
        if (isNaN(index) || index < 0 || index >= scheduleArr.length) {
            return bot.sendMessage(chatId, 'Некорректный индекс.');
        }
        if (scheduledJobs[chatId] && scheduledJobs[chatId][index]) {
            scheduledJobs[chatId][index].cancel();
            delete scheduledJobs[chatId][index];
        }
        scheduleArr.splice(index, 1);
        userSchedules[chatId] = scheduleArr;
        saveData();
        scheduleAllNotificationsForUser(chatId);
        bot.sendMessage(chatId, 'Пара удалена.');
        listSchedule(chatId);
    }
});